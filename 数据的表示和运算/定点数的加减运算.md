<font size = 9>$$定点数的加减运算$$</font>



计算机中可以 **用原码和补码** 进行 **定点数的加减运算**，**不会用反码** 进行加减运算。



# 一、原码的加减法运算

- **加法规则**：
  - 符号位 **相同**，则 **数值位相加**，结果 **符号位不变**。
    - 若最高数值位相加产生进位，则发生 **溢出**。
  - 符号位 **不同**，则 **绝对值大的减去绝对值小的**，结果 **符号位与绝对值大的数相同**。

- **减法规则**：
  - 先将 **减数** 的 **符号取反**
  - 在将 **被减数** 与 **符号取反后的减数** 按原码的 **加法** 进行运算。

**注意**：原码的加减运算规则实现较复杂，需要将符号位和数值位分开处理。所以计算机采用的是 **补码的加减运算**。





# 二、补码的加减法运算

## （一）运算规则
设 **机器字长为 $n$**

- **加法规则**：
  - **两个数的补码直接相加**。
  - $[A + B]_补 = [A]_补 + [B]_补（mod 2^n）$

- **减法规则**：
  - **被减数与减数的负数补码相加**。
  - $[A - B]_补 = [A]_补 + [-B]_补（mod 2^n）$

- 符号位与数值位一起参加运算，最终运算结果的高位丢弃，保留 n 位，运算结果也是补码。

## （二）溢出判断

若机器字长为 n，则n位补码整数表示的范围为 $-2^{n-1}$ ~ $2^{n-1} - 1$

<div align=center>

![](./图片/上溢下溢.png){width="400px"}
</div>

- 只有 $正数 + 正数$ 才会 **上溢**（超过补码正数的范围），即结果的符号位为负。
- 只有 $负数 + 负数$ 才会 **下溢**（超过补码负数的范围），即结果的符号位为正。

补码定点数加减运算溢出判断的方法有三种：**采用一位符号位**、**采用一位符号位根据数值位的进位情况判断溢出**、**采用双符号位**。

### 1. 采用一位符号位（模 2 补码）

设 **操作数 $A$** 的符号位为 **$A_s$**，**操作数 $B$** 的符号位为 **$B_s$**，**运算结果** 的符号位为 **$S_s$**，则溢出逻辑表达式为：
**$$V = A_s B_s \overline{S_s} + \overline{A_s} \: \overline{B_s} S_s$$**

- 若 **V = 0**，表示 **无溢出**。
- 若 **V = 1**，表示 **有溢出**。
- 只要参加操作的两个数的符号相同，结果又与原操作数的符号不同，则表示溢出。



### 2. 采用一位符号位根据数值位的进位情况判断溢出

根据 **符号位（最高位）的进位 $C_n$** 与 **最高数位（次高位）的进位 $C_{n-1}$** 是否相同来判断溢出，逻辑表达式为：

**$$V = C_n \bigoplus C_{n-1}$$**

- 若 **V = 0**，则 $C_n$ 与 $C_{n-1}$ **相同**，说明 **无溢出**。
- 若 **V = 1**，则 $C_n$ 与 $C_{n-1}$ **不相同**，说明 **有溢出**。



### 3. 采用双符号位（模 4 补码）

为每个数设置 **两个符号位**，记一个符号位为 **$S_{S1}$**，另一个符号位为 **$S_{S2}$**，则溢出逻辑表达式为：

**$$V = S_{S1} \bigoplus S_{S2}$$**

- 若 **V = 0**，表示 **无溢出**。
  - $S_{S1}S_{S2} = 00$，表示结果为正数，无溢出。
  - $S_{S1}S_{S2} = 11$，表示结果为负数，无溢出。
- 若 **V = 1**，表示 **有溢出**。
  - $S_{S1}S_{S2} = 01$，表示结果正溢出。
  - $S_{S1}S_{S2} = 00$，表示结果负溢出。

- 最高位符号（$S_{S1}$）代表真正的符号
- 次位符号（$S_{S2}$）代表结果得出的错误符号

- 两个符号位在实际存储时只存储一个符号位，运算前会复制另一个符号位。